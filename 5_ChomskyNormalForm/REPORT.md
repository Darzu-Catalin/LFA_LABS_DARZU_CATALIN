# Chomsky Normal Form Converter

**Course**: Formal Languages and Finite Automata
**Author**: Darzu Catalin
**Variant**: 13

---

## 1. Theory

Chomsky Normal Form (CNF) is a standard restriction applied to Context-Free Grammars (CFGs) to simplify parsing algorithms and theoretical proofs.

A grammar is in **CNF** if **every production rule** is of one of the following types:

* `A → BC` – where `A`, `B`, and `C` are **nonterminal symbols** (and `B`, `C` are not the start symbol);
* `A → a` – where `a` is a **terminal symbol**;
* **Exception**: `S → ε` is allowed only if the empty string `ε` belongs to the language generated by the grammar.

### Advantages of CNF

* Enables efficient parsing algorithms (e.g. **Cocke–Younger–Kasami (CYK)**);
* Simplifies decision procedures such as membership testing;
* Provides a clear basis for proving equivalence between CFGs and pushdown automata (PDA);
* Facilitates optimizations in compiler parser implementations.

---

## 2. Objectives

The main goal is to build an automated converter that transforms an arbitrary CFG into CNF by applying the following sequence of steps:

1. **Eliminate ε-productions** – rules that produce the empty string;
2. **Eliminate unit-productions** – rules of the form `A → B`, where both `A` and `B` are nonterminals;
3. **Remove useless symbols** – nonterminals that are non-productive or unreachable;
4. **Replace terminals in complex productions** with intermediate nonterminals;
5. **Binarize long productions** – split rules of length > 2 into chains of binary productions.

We implement these steps in a modular Python program, allowing testing on multiple grammar variants.

---

## 3. Implementation Details

The code is organized into functions, each handling one transformation step. Below are two representative examples:

### 3.1 Grammar Parsing

```python
def _parse(lines: List[str]) -> Dict[str, Set[Tuple[str, ...]]]:
    g: Dict[str, Set[Tuple[str, ...]]] = {}
    for l in lines:
        L, R = l.split("->")
        L = L.strip()
        for alt in R.split("|"):
            alt = alt.strip()
            g.setdefault(L, set()).add(
                tuple(alt) if alt and alt != EPS else tuple()
            )
    return g
```

This function converts production lines into a Python dictionary where:

* The **key** is the left-hand side nonterminal;
* The **value** is a set of tuples representing each right-hand side alternative.

---

### 3.2 ε‑Production Elimination

```python
def _rm_eps(g: Dict[str, Set[Tuple[str, ...]]], start="S"):
    nullable, changed = set(), True
    while changed:
        changed = False
        for A, prods in g.items():
            if (
                A not in nullable
                and any((not p) or all(s in nullable for s in p) for p in prods)
            ):
                nullable.add(A)
                changed = True

    ng = {A: set() for A in g}
    for A, prods in g.items():
        for p in prods:
            idx = [i for i, s in enumerate(p) if s in nullable]
            subsets = [[]]
            for i in idx:
                subsets += [old + [i] for old in subsets]
            for sub in subsets:
                alt = tuple(sym for i, sym in enumerate(p) if i not in sub)
                if alt or A == start:
                    ng[A].add(alt)
    return ng
```

This function identifies nullable nonterminals and generates all variants of productions without them, retaining `ε` only for the start symbol.

---

## 4. Variant 13: Original Grammar

```
1. S → aB
2. S → DA
3. A → a
4. A → BD
5. A → bDAB
6. B → b
7. B → BA
8. D → ε
9. D → BA
10. C → BA
```

We will apply steps 1–5 to this grammar.

---

## 5. Results for Variant 13

*(Outputs are printed to the Python console upon execution.)*

1. **Initial Grammar**
2. **After ε‑elimination**
3. **After unit‑production removal**
4. **After removing useless symbols**
5. **After terminal replacement and binarization**

The final result is a CNF grammar containing only productions of the form `A → BC`, `A → a`, and optionally `S → ε`.

---

## 6. Conclusion

We built a complete, generic converter from CFG to CNF, with visibility into each transformation step.

**Author**: Darzu Catalin
**Variant**: 13
**Date**: 05/05/2025

---

## 7. References

* Chomsky, N. (1959). *On certain formal properties of grammars*. *Information and Control*.
* Aho, A. V., & Ullman, J. D. (1972). *The Theory of Parsing, Translation, and Compiling*.
* Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation* (3rd ed.).
* Lecture notes – Technical University of Moldova, course "Formal Languages and Finite Automata".
